package lib

import (
	"strings"
	"strconv"
)

func move(ndisks,startPeg,endPeg int,tmp_v *[]int, return_list *[][]int){
	// move: moves a pile of shapes from the source color to the target color
	if ndisks>0 {
		move(ndisks-1,startPeg,3-startPeg-endPeg,tmp_v,return_list);
		element:=-searchIndexInt(startPeg,reverseInts(*tmp_v))-1;
		(*tmp_v)[len(*tmp_v)+element]=endPeg;
		*return_list=append(*return_list, []int{startPeg,endPeg,absInt(element+1)})
		move(ndisks-1,3-startPeg-endPeg,endPeg,tmp_v,return_list)
	}
}

func hanoiMoves(vitamin []int,tmp_v *[]int, size int)[][]int{
	// hanoiMoves: starts from the final stage searching where to put the next disk from the bottom of the pile
	var return_values = make([][]int,0,0)
	for i:=size-1;i>-1;i--{
		t := size-1-i
		if vitamin[t]==(*tmp_v)[t]{continue}
		if i>0 {
			move(i, (*tmp_v)[t], 3-vitamin[t]-(*tmp_v)[t], tmp_v, &return_values)
		}
		return_values=append(return_values,[]int{(*tmp_v)[t],vitamin[t], i})
		(*tmp_v)[t]=vitamin[t]
	}
	return return_values;
}

func reverseMovesAddNames(l [][]int,names []int,s_vitamin string)[][]string{
	// reverseMovesAddNames: changes the order and add the proper names to the array of the moves
	var result = make([][]string,0,0)
	len_names := len(names);
	for _,item := range reverseIntsItems(l) {
		h_num := strconv.Itoa(names[len_names-1 - item[2]])
		tmp := []string{h_num,string(s_vitamin[item[1]]),string( s_vitamin[item[0]])};
		result = append(result,tmp)
	}
	return result
}

func MakeAllWhite(Vitamin_String string)[][]string{
	//MakeAllWhite: return the array of moves needed to set all of the colors
	// of the shapes to white accordingly with the Maxi-Maxi Principle.
	Vitamin_String = strings.TrimSpace(Vitamin_String)
	colors := "BGW"
	var tmp_v =  make([]int,0,0)
	var names_v = make([]int,0,0)
	to_loop := strings.Split(Vitamin_String," ")
	for _,item := range to_loop {
		value, _ := strconv.Atoi(item[:len(item)-1])
		color := string(item[len(item)-1])
		tmp_v = append(tmp_v, searchIndexString(colors, color))
		names_v = append(names_v, value)
	}
	size := len(tmp_v)
	var h_array = make([]int,size,size)
	for i:= range h_array{h_array[i]=2}
	move_list := hanoiMoves(tmp_v,&h_array,size)
	return reverseMovesAddNames(move_list,names_v,colors)
}

func MakeAllWhiteStatus(s_vitamins string, list_moves[][]string)[]string{
	// makeAllWhiteStatus: take as input the start status and the moves and return and array
	//                     with the list of status generated by the moves
	s_vitamins = strings.TrimSpace(s_vitamins)
	s_vitamin_split := strings.Split(s_vitamins," ")
	key := Map(s_vitamin_split, func(item string)string{return item[:len(item)-1]})
	value := Map(s_vitamin_split, func(item string)string{return string(item[len(item)-1])})
	tmp_dict := map[string]string{}
	for k,_ := range value {tmp_dict[key[k]]=value[k]}
	result:=[]string{s_vitamins}

	for _, c := range list_moves{
		tmp_dict[c[0]] = c[len(c)-1]
		tmp_items :=[]string{}
		for k,v := range tmp_dict {tmp_items = append(tmp_items,k+v)}
		result = append(result, strings.Join(tmp_items, " ") )
	}
	return result
}